
```{r, setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  tidy = FALSE,
  error = FALSE,
  fig.width = 8,
  fig.height = 8)
```

# async

> Asynchronous HTTP

[![Linux Build Status](https://travis-ci.org/r-lib/async.svg?branch=master)](https://travis-ci.org/r-lib/async)
[![Windows Build status](https://ci.appveyor.com/api/projects/status/github/r-lib/async?svg=true)](https://ci.appveyor.com/project/gaborcsardi/async)
[![](http://www.r-pkg.org/badges/version/async)](http://www.r-pkg.org/pkg/async)
[![CRAN RStudio mirror downloads](http://cranlogs.r-pkg.org/badges/async)](http://www.r-pkg.org/pkg/async)
[![Coverage Status](https://img.shields.io/codecov/c/github/r-lib/async/master.svg)](https://codecov.io/github/r-lib/async?branch=master)

The `async` package brings asynchronous (async) computation and I/O to R.
It uses an event loop to schedule asynchronous functions that
report their results via deferred values.

## Installation

```{r eval = FALSE}
devtools::install_github("r-lib/async")
```

## Introduction

The `async` package brings asychronous I/O and computation to R. As a first
step it implements asynchronous HTTP requests.

## Async functions

Asynchronous computation is carried out in asynchronous (async) functions.
An async function is special:
- it can stop its execution to wait for results from other async
  functions.
- it can create deferred values, that represent asynchronous computation.
- it returns a deferred value.
- it can call other asynchronous functions.

The `async` package contains some async functions:
- `delay()` invokes computation that is carried out after a timer expires.
- `http_get()` and `http_head()` perform HTTP requests, asynchronously.
- `async_constant()` is an async function that represents a value.

## Synchronization barriers

Asynchronous computation is carried out in async functions, and async
functions can call other async functions. Usually synchronous functions
cannot call asynchronous functions, except for a special function:
`synchronise()`. `synchronise()` creates a synchronization barrier. It
can call an async function, and it waits until the async function is run
to completion. `synchronise()` is a tool that allows embedding
asynchronous code into synchronous code. All examples in this intro are
embedded into a `synchronise()` call.

## Deferred Values

Asynchronous computation is represented by deferred values. In `async`
a deferred value is an [R6](https://github.com/wch/R6) object, so it has
reference semantics. In some other programming languages deferred values
are called futures or promises.

You can think of a deferred value as a placeholder for a (non-deferred)
value that is not yet known. A deferred value can be in three states:
* pending
* fulfilled
* rejected

It starts up in the pending state, and once it is fulfilled or rejected,
it cannot change.

Typically a deferred value is created by requesting asynchronous I/O, like
an HTTP GET request with the `http_get()` function.

## Deferred chains

While the eventual value of a pending deferred is not known, we can still
operate on it, by declaring code that is to be executed, once the value
will be known.

```{r}
library(async)
afun <- function() {
  def <- http_get("https://httpbin.org")
  def$then(function(response) response$status_code)
}
synchronise(afun())
```

`then()` returns another deferred, which also has a `then()` method,
so it is chainable. It is possible to split the chain, and call the
`then()` method on the same deferred multiple times, to schedule multiple
operations on the resolved value.

## Synchronization

The `synchroniset()` function allows mixing synchronous and asynchronous
code. It can be called on an expression that creates deferred values,
and it stops the synchronous until all deferred values are resolved
(i.e. fulfilled or rejected). Importantly, `synchronise()` creates a new
event loop and works towards he resolution of all deferred values
created within this event loop.

In a typical application, a function is implemented asynchronously, and
then used synchronously by the interactive user, or another piece of
synchronous code, via `synchronise()` calls. The following example makes
three HTTP requests in parallel:

```{r}
afun <- function() {
  http_status <- function(url) {
    http_get(url)$then(function(response) response$status_code)
  }
  r1 <- http_status("https://httpbin.org/status/403")
  r2 <- http_status("https://httpbin.org/status/404")
  r3 <- http_status("https://httpbin.org/status/200")
  when_all(r1, r2, r3)
}
synchronise(afun())
```

## Error handling

There are two ways to handle errors in asynchronous code.
`then()` can take a second argument, another function, that is called
if and when the deferred value is rejected. This function catches errors
and by default turns them into regular values. Alternatively, they can
also re-throw the error by calling `stop()`.

```{r}
afun <- function() {
  u1 <- http_get("https://httpbin.org")$
    then(function() "web server is up")$
    catch(function() "web server is down")
  u2 <- http_get("non-existing-url.for-sure")$
    then(function() "web server is up")$
    catch(function() "web server is down")
  when_all(u1, u2)
}
synchronise(afun())
```

The `catch()` method is handy to write an error handler only, it is
equivalent to `then()` with its first argument set to `NULL`.

Errors can also be handled synchronously. If an error is not handled
asynchronously in a `then()` or `catch()` method, then the deferred value
will throw an error when it is `synchronise()`-ed. This can be caught via
`tryCatch()`.

## Async Iterators

`async` provides some utilities that make it easier to deal with
collections of deferred values. E.g. `async_map()` applies an async function
to a list and returns a single deferred value for the whole result.
`async_detect()` finds a value in a list that satisfies an async predicate
function, etc.

The current iterators:
* `async_map()` applies an async function to all elements of a vector or
  list (collection).
* `async_detect()` finds an element of a collection that passed an async
  truth test.
* `async_every()` checks if every element of a collection satisfies an async
  predicate. `async_some()` checks if any element does that.
* `async_filter()` keeps elements that pass an async truth test.
* `async_timeout()` runs an async function with a timeout.

## Async Control Flow

Control flow with deferred values can be challenging. Some helpers:
* `async_reflect()` creates an async function that always succeeds.
  This is useful if you want to apply it to a collection, and don't
  want to stop at the first error.
* `async_retry()` tries an async function a number of times.
  `async_retryable()` turns a regular function into a retryable one.
* `async_sequence()` chains two async functions. Calling their sequence is
  equivalent calling `then()` on them, but `async_sequence()` is easier to
  use programmatically.
* `async_until()` and `async_whilst()` let you call an async function
  repeatedly, until or while a (syncronous or asynchronous) condition
  holds.

## Other Async Utilities

* `async_constant()` takes a value and creates and asynchronous function
  that returns that value.
* `when_all()` returns a deferred value that is resolved when all supplied
  deferred values are resolved. `when_any()` and `when_some()` are similar,
  but condition on a single, or the specified number of deferred values.

## Examples

### Parallel API Queries

Query the crandb API, get the authors of the packages with the most
reverse dependencies.

```{r}
fromJSON <- function(x) jsonlite::fromJSON(x, simplifyVector = FALSE)
revdep_authors <- function() {
  get_author <- function(package) {
    url <- paste0("https://crandb.r-pkg.org/", package)
    http_get(url)$
      then(~ fromJSON(rawToChar(.$content)))$
      then(~ .$Author)
  }

  http_get("https://crandb.r-pkg.org/-/topdeps/devel")$
    then(~ fromJSON(rawToChar(.$content)))$
    then(~ names(unlist(.)))$
    then(~ async_map(., get_author))
}
synchronise(revdep_authors())[1:3]
```

### Checking URLs

The following code returns the 2 URLs that respond first.

```{r}
fastest_two <- function(urls) {
  qs <- lapply(urls, http_head)
  t2 <- when_some(2, .list = qs)$
  then(function(top2) vapply(top2, "[[", character(1), "url"))
}
urls <- c("https://cran.rstudio.com", "https://cran.r-project.org",
          "https://www.stats.bris.ac.uk/R/", "https://cran.uib.no/")
synchronise(
  fastest_two(urls)
)
```

## License

MIT Â© [RStudio Inc](https://rstudio.com)
